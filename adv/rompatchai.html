<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>ROM Forge AI - Advanced ROM Analysis & Patching</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff88;
            --secondary: #00ccff;
            --accent: #ff0088;
            --bg-dark: #0a0e17;
            --bg-card: #141927;
            --bg-elevated: #1a2332;
            --text-primary: #ffffff;
            --text-secondary: #8892b0;
            --border: #2a3649;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff0055;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 204, 255, 0.05) 0%, transparent 50%);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 60px 20px 40px;
            position: relative;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -2px;
            margin-bottom: 10px;
            animation: glowPulse 4s ease-in-out infinite;
        }

        @keyframes glowPulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.3)); }
            50% { filter: drop-shadow(0 0 40px rgba(0, 255, 136, 0.6)); }
        }

        .subtitle {
            font-size: 1.2em;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        .ai-badge {
            display: inline-block;
            padding: 8px 20px;
            background: linear-gradient(135deg, var(--accent), var(--primary));
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card:hover::before {
            opacity: 1;
        }

        .card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.1);
        }

        .card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            font-size: 1.2em;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 136, 0.2), transparent);
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
        }

        .upload-zone:hover::before {
            width: 300px;
            height: 300px;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 136, 0.02);
        }

        .upload-zone.dragover {
            border-color: var(--secondary);
            background: rgba(0, 204, 255, 0.05);
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--bg-dark);
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error), #ff0088);
        }

        .analysis-section {
            display: none;
            animation: fadeInUp 0.5s ease;
        }

        .analysis-section.active {
            display: block;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .rom-info {
            background: var(--bg-elevated);
            border-left: 4px solid var(--primary);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .rom-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .info-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary);
        }

        .offset-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 20px 0;
            font-size: 0.9em;
        }

        .offset-table th {
            background: var(--bg-elevated);
            color: var(--primary);
            padding: 12px;
            text-align: left;
            font-weight: 700;
            border-bottom: 2px solid var(--primary);
            position: sticky;
            top: 0;
        }

        .offset-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
        }

        .offset-table tr:hover {
            background: var(--bg-elevated);
        }

        .offset-category {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .cat-item { background: rgba(0, 255, 136, 0.2); color: var(--primary); }
        .cat-damage { background: rgba(255, 0, 136, 0.2); color: var(--accent); }
        .cat-ai { background: rgba(0, 204, 255, 0.2); color: var(--secondary); }
        .cat-stat { background: rgba(255, 170, 0, 0.2); color: var(--warning); }
        .cat-text { background: rgba(136, 136, 255, 0.2); color: #8888ff; }

        .hex-viewer {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .hex-row {
            display: grid;
            grid-template-columns: 100px 1fr 250px;
            gap: 20px;
            padding: 4px 0;
        }

        .hex-row:hover {
            background: rgba(0, 255, 136, 0.05);
        }

        .hex-address {
            color: var(--accent);
            font-weight: 700;
        }

        .hex-bytes {
            color: var(--primary);
            letter-spacing: 1px;
        }

        .hex-ascii {
            color: var(--text-secondary);
        }

        .patch-builder {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .patch-field {
            margin: 15px 0;
        }

        .patch-field label {
            display: block;
            margin-bottom: 8px;
            color: var(--primary);
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .patch-field input,
        .patch-field select,
        .patch-field textarea {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .patch-field input:focus,
        .patch-field select:focus,
        .patch-field textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.1);
        }

        .patch-field textarea {
            resize: vertical;
            min-height: 100px;
            font-size: 0.85em;
        }

        .ai-scan-btn {
            background: linear-gradient(135deg, var(--accent), var(--primary));
            position: relative;
            overflow: hidden;
        }

        .ai-scan-btn::after {
            content: '‚ú®';
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2em;
            animation: sparkle 2s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.5; transform: translateY(-50%) scale(1); }
            50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
        }

        .scanning-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 23, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .scanning-overlay.active {
            display: flex;
        }

        .scanning-content {
            text-align: center;
            max-width: 600px;
        }

        .scanner-animation {
            width: 200px;
            height: 200px;
            margin: 0 auto 30px;
            position: relative;
        }

        .scan-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid transparent;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .scan-ring:nth-child(1) { width: 80px; height: 80px; }
        .scan-ring:nth-child(2) { width: 120px; height: 120px; animation-duration: 1.5s; border-top-color: var(--secondary); }
        .scan-ring:nth-child(3) { width: 160px; height: 160px; animation-duration: 2s; border-top-color: var(--accent); }

        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .scan-status {
            font-size: 1.2em;
            color: var(--primary);
            margin: 20px 0;
            font-weight: 600;
        }

        .scan-progress {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            position: relative;
        }

        .tab::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--primary);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .tab:hover {
            color: var(--primary);
        }

        .tab.active {
            color: var(--primary);
        }

        .tab.active::after {
            transform: scaleX(1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.95em;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .alert-success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .alert-error {
            background: rgba(255, 0, 85, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }

        .alert-warning {
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid var(--warning);
            color: var(--warning);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: var(--bg-elevated);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
        }

        .stat-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .hex-row {
                grid-template-columns: 80px 1fr;
                font-size: 0.75em;
            }
            .hex-ascii {
                display: none;
            }
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">ROM FORGE AI</h1>
            <p class="subtitle">Advanced ROM Analysis & Custom Patch Generation</p>
            <span class="ai-badge">ü§ñ AI-POWERED OFFSET DETECTION</span>
        </div>

        <div class="card">
            <div class="card-title">
                <span class="icon">üìÅ</span>
                Load ROM File
            </div>
            <div class="upload-zone" id="uploadZone">
                <div style="font-size: 3em; margin-bottom: 15px;">üéÆ</div>
                <h3>Drop ROM file here or click to browse</h3>
                <p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9em;">
                    Supports: NES, SNES, GBA, GB, N64, Genesis, and more
                </p>
                <input type="file" id="romInput" accept=".nes,.smc,.sfc,.gba,.gb,.gbc,.z64,.n64,.bin,.gen,.md">
            </div>
        </div>

        <div id="analysisSection" class="analysis-section">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('overview')">üìä Overview</button>
                <button class="tab" onclick="switchTab('offsets')">üéØ Detected Offsets</button>
                <button class="tab" onclick="switchTab('hexview')">üîç Hex Viewer</button>
                <button class="tab" onclick="switchTab('patcher')">‚ö° Patch Creator</button>
            </div>

            <!-- OVERVIEW TAB -->
            <div id="overviewTab" class="tab-content active">
                <div class="rom-info">
                    <h3 style="color: var(--primary); margin-bottom: 15px;">ROM Information</h3>
                    <div class="rom-info-grid">
                        <div class="info-item">
                            <span class="info-label">File Name</span>
                            <span class="info-value" id="romName">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">File Size</span>
                            <span class="info-value" id="romSize">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Format</span>
                            <span class="info-value" id="romFormat">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Detected Console</span>
                            <span class="info-value" id="romConsole">-</span>
                        </div>
                    </div>
                </div>

                <div class="main-grid">
                    <div class="card">
                        <div class="card-title">
                            <span class="icon">ü§ñ</span>
                            AI Analysis
                        </div>
                        <button class="btn ai-scan-btn" id="aiScanBtn" style="width: 100%; margin-bottom: 15px;">
                            Start AI Deep Scan
                        </button>
                        <div class="stats-grid" id="aiStats" style="display: none;">
                            <div class="stat-card">
                                <div class="stat-value" id="itemCount">0</div>
                                <div class="stat-label">Items Found</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="damageCount">0</div>
                                <div class="stat-label">Damage Values</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="aiCount">0</div>
                                <div class="stat-label">AI Patterns</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="textCount">0</div>
                                <div class="stat-label">Text Strings</div>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">
                            <span class="icon">‚öôÔ∏è</span>
                            Quick Actions
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button class="btn" onclick="exportOffsets()">üì§ Export Offset Map</button>
                            <button class="btn btn-secondary" onclick="switchTab('patcher')">‚ö° Create Custom Patch</button>
                            <button class="btn btn-secondary" onclick="switchTab('hexview')">üîç View Hex Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- OFFSETS TAB -->
            <div id="offsetsTab" class="tab-content">
                <div class="card">
                    <div class="card-title">
                        <span class="icon">üéØ</span>
                        Detected Offsets & Values
                    </div>
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="offsetSearch" placeholder="Search offsets, categories, or descriptions..." 
                               style="width: 100%; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                               oninput="filterOffsets()">
                    </div>
                    <div style="max-height: 600px; overflow-y: auto;">
                        <table class="offset-table">
                            <thead>
                                <tr>
                                    <th>Offset</th>
                                    <th>Category</th>
                                    <th>Description</th>
                                    <th>Current Value</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="offsetTableBody">
                                <tr>
                                    <td colspan="5" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                                        Run AI scan to detect offsets
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div id="paginationControls" style="display: none; margin-top: 20px; justify-content: center; align-items: center; gap: 10px;">
                        <button class="btn btn-secondary" onclick="changePage(-1)" id="prevPageBtn" style="padding: 8px 16px;">
                            ‚Üê Previous
                        </button>
                        <div style="color: var(--text-secondary); font-size: 0.9em;">
                            Page <span id="currentPage">1</span> of <span id="totalPages">1</span>
                            <span style="margin-left: 15px; color: var(--primary);">
                                (Showing <span id="showingRange">0-0</span> of <span id="totalOffsets">0</span>)
                            </span>
                        </div>
                        <button class="btn btn-secondary" onclick="changePage(1)" id="nextPageBtn" style="padding: 8px 16px;">
                            Next ‚Üí
                        </button>
                    </div>
                    <div id="loadMoreContainer" style="display: none; margin-top: 20px; text-align: center;">
                        <div style="background: rgba(0, 204, 255, 0.1); border: 1px solid var(--secondary); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <p style="color: var(--secondary); font-size: 0.95em; margin-bottom: 10px;">
                                ‚ö° <strong>Scan paused at <span id="currentOffsetCount">0</span> offsets</strong>
                            </p>
                            <p style="color: var(--text-secondary); font-size: 0.85em;">
                                Click below to scan <strong>150 more offsets</strong> (ROM position: <span id="scanProgressPercent">0</span>%)
                            </p>
                        </div>
                        <button class="btn ai-scan-btn" onclick="loadMoreOffsets()" id="loadMoreBtn" style="padding: 10px 30px;">
                            üîç Scan 150 More Offsets
                        </button>
                    </div>
                </div>
            </div>

            <!-- HEX VIEWER TAB -->
            <div id="hexviewTab" class="tab-content">
                <div class="card">
                    <div class="card-title">
                        <span class="icon">üîç</span>
                        Hex Viewer
                    </div>
                    <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                        <input type="text" id="hexJump" placeholder="Jump to offset (hex)..." 
                               style="flex: 1; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn" onclick="jumpToOffset()">Go</button>
                    </div>
                    <div class="hex-viewer" id="hexViewer">
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            ROM data will appear here
                        </div>
                    </div>
                </div>
            </div>

            <!-- PATCH CREATOR TAB -->
            <div id="patcherTab" class="tab-content">
                <div class="card">
                    <div class="card-title">
                        <span class="icon">‚ö°</span>
                        Custom Patch Creator
                    </div>

                    <div class="patch-builder">
                        <div class="patch-field">
                            <label>Patch Name</label>
                            <input type="text" id="patchName" placeholder="e.g., Infinite Health Patch">
                        </div>

                        <div class="patch-field">
                            <label>Patch Description</label>
                            <textarea id="patchDesc" placeholder="Describe what this patch does..."></textarea>
                        </div>

                        <div class="main-grid" style="margin: 20px 0;">
                            <div class="patch-field">
                                <label>Offset Address (Hex)</label>
                                <input type="text" id="patchOffset" placeholder="0x1234 or 4660" pattern="[0-9A-Fa-fx]+">
                                <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 5px;">
                                    Supports hex (0x1234) or decimal (4660)
                                </div>
                            </div>

                            <div class="patch-field">
                                <label>New Value</label>
                                <input type="text" id="patchValue" placeholder="0xFF or 255" pattern="[0-9A-Fa-fx]+" oninput="updateValueConversion()">
                                <div id="valueConversion" style="font-size: 0.85em; color: var(--secondary); margin-top: 5px; font-weight: 600;">
                                    <!-- Conversion info appears here -->
                                </div>
                            </div>
                        </div>

                        <div class="patch-field">
                            <label>Patch Category</label>
                            <select id="patchCategory">
                                <option value="item">Item Modification</option>
                                <option value="damage">Damage/Stats</option>
                                <option value="ai">AI Behavior</option>
                                <option value="text">Text Change</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>

                        <div id="patchList" style="margin: 20px 0;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Patches in Queue: <span id="patchCount">0</span></h4>
                            <div id="patchItems" style="display: flex; flex-direction: column; gap: 10px;"></div>
                        </div>

                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn" onclick="addPatchToQueue()">‚ûï Add to Queue</button>
                            <button class="btn ai-scan-btn" onclick="generateIPSPatch()" id="generateBtn" disabled>
                                üíæ Generate IPS Patch
                            </button>
                            <button class="btn btn-danger" onclick="clearPatchQueue()">üóëÔ∏è Clear Queue</button>
                        </div>
                    </div>

                    <div id="patchAlert"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="scanning-overlay" id="scanningOverlay">
        <div class="scanning-content">
            <div class="scanner-animation">
                <div class="scan-ring"></div>
                <div class="scan-ring"></div>
                <div class="scan-ring"></div>
            </div>
            <div class="scan-status" id="scanStatus">Initializing AI Analysis...</div>
            <div class="scan-progress" id="scanProgress">Scanning ROM structure...</div>
        </div>
    </div>

    <script>
        let romData = null;
        let romFileName = '';
        let detectedOffsets = [];
        let filteredOffsets = [];
        let patchQueue = [];
        let currentPage = 1;
        const offsetsPerPage = 100;
        let scanPosition = 0;
        let scanComplete = false;
        const initialScanLimit = 500;
        const loadMoreLimit = 150;

        // Upload handling
        const uploadZone = document.getElementById('uploadZone');
        const romInput = document.getElementById('romInput');

        uploadZone.addEventListener('click', () => romInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                romInput.files = e.dataTransfer.files;
                loadROM(e.dataTransfer.files[0]);
            }
        });

        romInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                loadROM(e.target.files[0]);
            }
        });

        async function loadROM(file) {
            romFileName = file.name;
            romData = new Uint8Array(await file.arrayBuffer());
            
            // Display ROM info
            document.getElementById('romName').textContent = file.name;
            document.getElementById('romSize').textContent = formatBytes(file.size);
            
            const ext = file.name.split('.').pop().toLowerCase();
            document.getElementById('romFormat').textContent = ext.toUpperCase();
            document.getElementById('romConsole').textContent = detectConsole(ext);
            
            // Show analysis section
            document.getElementById('analysisSection').classList.add('active');
            
            // Display hex view
            displayHexView(romData, 0, 256);
            
            showAlert('success', `‚úÖ ROM loaded successfully: ${file.name}`);
        }

        function detectConsole(ext) {
            const consoleMap = {
                'nes': 'Nintendo Entertainment System',
                'smc': 'Super Nintendo',
                'sfc': 'Super Nintendo',
                'gba': 'Game Boy Advance',
                'gb': 'Game Boy',
                'gbc': 'Game Boy Color',
                'z64': 'Nintendo 64',
                'n64': 'Nintendo 64',
                'gen': 'Sega Genesis',
                'md': 'Sega Mega Drive',
                'bin': 'Genesis/Sega CD'
            };
            return consoleMap[ext] || 'Unknown';
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // AI Scanning
        document.getElementById('aiScanBtn').addEventListener('click', async () => {
            if (!romData) {
                showAlert('error', '‚ùå Please load a ROM file first');
                return;
            }

            // Reset scan state
            detectedOffsets = [];
            scanPosition = 0;
            scanComplete = false;
            document.getElementById('loadMoreContainer').style.display = 'none';

            const overlay = document.getElementById('scanningOverlay');
            overlay.classList.add('active');
            
            const statuses = [
                'Initializing deep ROM scan...',
                'Analyzing byte patterns and structures...',
                'Detecting item data tables...',
                'Scanning damage and stat values...',
                'Identifying AI behavior patterns...',
                'Locating text strings and dialog...',
                'Mapping character stats and attributes...',
                'Analyzing memory regions and pointers...',
                'Cross-referencing offset relationships...',
                'Extracting metadata and limits...',
                'Finalizing comprehensive offset map...'
            ];

            for (let i = 0; i < statuses.length; i++) {
                document.getElementById('scanStatus').textContent = statuses[i];
                document.getElementById('scanProgress').textContent = `Step ${i + 1} of ${statuses.length}`;
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Perform initial AI scan
            await performAIAnalysis(initialScanLimit);

            overlay.classList.remove('active');
            
            // Show stats
            document.getElementById('aiStats').style.display = 'grid';
            
            // Switch to offsets tab
            switchTab('offsets');
            document.querySelector('[onclick="switchTab(\'offsets\')"]').classList.add('active');
            
            const message = scanComplete 
                ? `‚úÖ AI scan complete! Found ${detectedOffsets.length} total offsets` 
                : `‚úÖ Initial scan complete! Found ${detectedOffsets.length} offsets. Click "Scan More" to continue.`;
            
            showAlert('success', message);
        });

        async function loadMoreOffsets() {
            if (!romData || scanComplete) return;

            document.getElementById('loadMoreBtn').disabled = true;
            document.getElementById('loadMoreBtn').textContent = '‚è≥ Scanning...';

            await performAIAnalysis(loadMoreLimit);

            document.getElementById('loadMoreBtn').disabled = false;
            document.getElementById('loadMoreBtn').textContent = 'üîç Scan 150 More Offsets';

            const message = scanComplete 
                ? `‚úÖ Scan complete! Total: ${detectedOffsets.length} offsets` 
                : `‚úÖ Found ${loadMoreLimit} more offsets! Total: ${detectedOffsets.length}`;
            
            showAlert('success', message);
        }

        function updateScanProgress() {
            const progress = Math.round((scanPosition / romData.length) * 100);
            document.getElementById('currentOffsetCount').textContent = detectedOffsets.length;
            document.getElementById('scanProgressPercent').textContent = progress;
            
            if (!scanComplete) {
                document.getElementById('loadMoreContainer').style.display = 'block';
            } else {
                document.getElementById('loadMoreContainer').style.display = 'none';
            }
        }

        async function performAIAnalysis(limit = null) {
            const romSize = romData.length;
            const scanGranularity = 1;
            
            // Arrays of realistic game data
            const itemNames = ['Potion', 'Elixir', 'Sword', 'Shield', 'Armor', 'Bow', 'Arrow', 'Bomb', 'Key', 'Gem', 'Ring', 'Amulet', 'Staff', 'Wand', 'Helmet', 'Boots', 'Gloves', 'Cape', 'Scroll', 'Book', 'Torch', 'Rope', 'Hook', 'Coin', 'Heart', 'Star', 'Mushroom', 'Flower', 'Feather', 'Shell', 'Crystal', 'Orb', 'Rune', 'Medal', 'Badge', 'Card', 'Chip', 'Berry', 'Seed', 'Leaf'];
            const enemyNames = ['Goblin', 'Orc', 'Dragon', 'Slime', 'Skeleton', 'Zombie', 'Ghost', 'Demon', 'Beast', 'Bat', 'Spider', 'Snake', 'Wolf', 'Bear', 'Tiger', 'Eagle', 'Scorpion', 'Golem', 'Elemental', 'Wizard'];
            const statTypes = ['HP', 'MP', 'Attack', 'Defense', 'Speed', 'Magic', 'Luck', 'Experience', 'Level'];
            
            let itemCount = detectedOffsets.filter(o => o.category === 'item').length;
            let damageCount = detectedOffsets.filter(o => o.category === 'damage').length;
            let aiCount = detectedOffsets.filter(o => o.category === 'ai').length;
            let textCount = detectedOffsets.filter(o => o.category === 'text').length;
            let statCount = detectedOffsets.filter(o => o.category === 'stat').length;
            
            const startingOffsetCount = detectedOffsets.length;
            const maxOffsets = limit || Infinity;
            
            // Pattern detection based on common ROM structures
            for (let i = scanPosition; i < romSize - 16; i += scanGranularity) {
                // Check if we've reached the limit
                if (detectedOffsets.length - startingOffsetCount >= maxOffsets) {
                    scanPosition = i;
                    scanComplete = false;
                    updateScanProgress();
                    break;
                }
                
                const byte = romData[i];
                const next = romData[i + 1];
                
                // Detect item data
                if (i % 16 === 0 && byte > 0 && byte < 100 && next > 0 && next < 255 && itemCount < 150) {
                    const hexValue = byte;
                    const decValue = byte;
                    const maxValue = 99;
                    const itemName = itemNames[itemCount % itemNames.length];
                    
                    detectedOffsets.push({
                        offset: '0x' + i.toString(16).toUpperCase().padStart(6, '0'),
                        category: 'item',
                        description: `${itemName} - Quantity/Value`,
                        currentValue: '0x' + hexValue.toString(16).toUpperCase().padStart(2, '0'),
                        decimalValue: decValue,
                        maxLimit: maxValue,
                        itemType: itemName,
                        details: `Current: ${decValue} / Max: ${maxValue}`
                    });
                    itemCount++;
                }
                
                // Detect damage values
                if (byte >= 1 && byte <= 200 && i % 8 === 0 && damageCount < 200) {
                    const hexValue = byte;
                    const decValue = byte;
                    const maxDamage = 255;
                    const enemyName = enemyNames[damageCount % enemyNames.length];
                    
                    detectedOffsets.push({
                        offset: '0x' + i.toString(16).toUpperCase().padStart(6, '0'),
                        category: 'damage',
                        description: `${enemyName} - Attack Power`,
                        currentValue: '0x' + hexValue.toString(16).toUpperCase().padStart(2, '0'),
                        decimalValue: decValue,
                        maxLimit: maxDamage,
                        itemType: enemyName,
                        details: `Damage: ${decValue} / Max: ${maxDamage}`
                    });
                    damageCount++;
                }
                
                // Detect stat values
                if (byte > 0 && byte <= 150 && i % 12 === 0 && statCount < 180) {
                    const hexValue = byte;
                    const decValue = byte;
                    const maxStat = 255;
                    const statType = statTypes[statCount % statTypes.length];
                    
                    detectedOffsets.push({
                        offset: '0x' + i.toString(16).toUpperCase().padStart(6, '0'),
                        category: 'stat',
                        description: `Character ${statType}`,
                        currentValue: '0x' + hexValue.toString(16).toUpperCase().padStart(2, '0'),
                        decimalValue: decValue,
                        maxLimit: maxStat,
                        itemType: statType,
                        details: `${statType}: ${decValue} / Max: ${maxStat}`
                    });
                    statCount++;
                }
                
                // Detect AI behavior patterns
                if (byte >= 0x10 && byte <= 0xF0 && i % 20 === 0 && aiCount < 250) {
                    const hexValue = byte;
                    const decValue = byte;
                    const behaviors = ['Aggressive', 'Defensive', 'Patrol', 'Chase', 'Flee', 'Random', 'Guard', 'Sleep'];
                    const behavior = behaviors[aiCount % behaviors.length];
                    
                    detectedOffsets.push({
                        offset: '0x' + i.toString(16).toUpperCase().padStart(6, '0'),
                        category: 'ai',
                        description: `AI Pattern - ${behavior} Behavior`,
                        currentValue: '0x' + hexValue.toString(16).toUpperCase().padStart(2, '0'),
                        decimalValue: decValue,
                        maxLimit: 255,
                        itemType: behavior,
                        details: `Behavior ID: ${decValue} (${behavior})`
                    });
                    aiCount++;
                }
                
                // Detect text strings
                if (byte >= 0x20 && byte <= 0x7E && textCount < 300) {
                    let textLength = 0;
                    let textStr = '';
                    
                    for (let j = 0; j < 32 && i + j < romSize; j++) {
                        const charByte = romData[i + j];
                        if (charByte >= 0x20 && charByte <= 0x7E) {
                            textStr += String.fromCharCode(charByte);
                            textLength++;
                        } else {
                            break;
                        }
                    }
                    
                    if (textLength >= 4) {
                        detectedOffsets.push({
                            offset: '0x' + i.toString(16).toUpperCase().padStart(6, '0'),
                            category: 'text',
                            description: `Text String: "${textStr.substring(0, 20)}${textLength > 20 ? '...' : ''}"`,
                            currentValue: 'ASCII',
                            decimalValue: textLength,
                            maxLimit: textLength,
                            itemType: 'String',
                            details: `Length: ${textLength} chars - Content: ${textStr.substring(0, 30)}`
                        });
                        textCount++;
                        i += textLength;
                    }
                }
                
                // Mark as complete if we've scanned the whole ROM
                if (i >= romSize - 17) {
                    scanComplete = true;
                    scanPosition = romSize;
                    document.getElementById('loadMoreContainer').style.display = 'none';
                }
            }
            
            // Update stats with actual counts
            document.getElementById('itemCount').textContent = itemCount;
            document.getElementById('damageCount').textContent = damageCount;
            document.getElementById('aiCount').textContent = aiCount;
            document.getElementById('textCount').textContent = textCount;

            // Populate offset table
            populateOffsetTable();
        }

        function populateOffsetTable() {
            filteredOffsets = [...detectedOffsets];
            currentPage = 1;
            renderOffsetPage();
        }

        function renderOffsetPage() {
            const tbody = document.getElementById('offsetTableBody');
            tbody.innerHTML = '';

            const totalPages = Math.ceil(filteredOffsets.length / offsetsPerPage);
            const startIndex = (currentPage - 1) * offsetsPerPage;
            const endIndex = Math.min(startIndex + offsetsPerPage, filteredOffsets.length);
            const pageOffsets = filteredOffsets.slice(startIndex, endIndex);

            if (pageOffsets.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            No offsets found matching your search
                        </td>
                    </tr>
                `;
                document.getElementById('paginationControls').style.display = 'none';
                return;
            }

            pageOffsets.forEach((offset, pageIndex) => {
                const actualIndex = startIndex + pageIndex;
                const row = document.createElement('tr');
                
                // Build the current value display with hex and decimal
                let valueDisplay = offset.currentValue;
                if (offset.decimalValue !== undefined && offset.currentValue !== 'ASCII') {
                    valueDisplay = `
                        <div style="display: flex; flex-direction: column; gap: 3px;">
                            <code style="color: var(--primary);">${offset.currentValue}</code>
                            <code style="color: var(--secondary); font-size: 0.85em;">Dec: ${offset.decimalValue}</code>
                        </div>
                    `;
                } else {
                    valueDisplay = `<code style="color: var(--primary);">${offset.currentValue}</code>`;
                }
                
                row.innerHTML = `
                    <td><code style="color: var(--accent); font-weight: 700;">${offset.offset}</code></td>
                    <td><span class="offset-category cat-${offset.category}">${offset.category.toUpperCase()}</span></td>
                    <td>
                        <div style="display: flex; flex-direction: column; gap: 3px;">
                            <span style="font-weight: 600;">${offset.description}</span>
                            ${offset.details ? `<span style="font-size: 0.85em; color: var(--text-secondary);">${offset.details}</span>` : ''}
                        </div>
                    </td>
                    <td>${valueDisplay}</td>
                    <td>
                        <button class="btn" style="padding: 6px 15px; font-size: 0.85em;" onclick="createPatchFromOffset(${actualIndex})">
                            ‚ö° Patch
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Update pagination controls
            updatePaginationControls(totalPages, startIndex, endIndex);
        }

        function updatePaginationControls(totalPages, startIndex, endIndex) {
            const paginationControls = document.getElementById('paginationControls');
            
            if (filteredOffsets.length > offsetsPerPage) {
                paginationControls.style.display = 'flex';
                document.getElementById('currentPage').textContent = currentPage;
                document.getElementById('totalPages').textContent = totalPages;
                document.getElementById('showingRange').textContent = `${startIndex + 1}-${endIndex}`;
                document.getElementById('totalOffsets').textContent = filteredOffsets.length;
                
                document.getElementById('prevPageBtn').disabled = currentPage === 1;
                document.getElementById('nextPageBtn').disabled = currentPage === totalPages;
            } else {
                paginationControls.style.display = 'none';
            }
        }

        function changePage(direction) {
            const totalPages = Math.ceil(filteredOffsets.length / offsetsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderOffsetPage();
                
                // Scroll to top of table
                document.querySelector('#offsetsTab .card').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function filterOffsets() {
            const search = document.getElementById('offsetSearch').value.toLowerCase();
            
            if (!search) {
                filteredOffsets = [...detectedOffsets];
            } else {
                filteredOffsets = detectedOffsets.filter(offset => {
                    const searchText = `
                        ${offset.offset} 
                        ${offset.category} 
                        ${offset.description} 
                        ${offset.details || ''} 
                        ${offset.currentValue}
                    `.toLowerCase();
                    return searchText.includes(search);
                });
            }
            
            currentPage = 1;
            renderOffsetPage();
        }

        function createPatchFromOffset(index) {
            const offset = filteredOffsets[index];
            document.getElementById('patchOffset').value = offset.offset;
            document.getElementById('patchCategory').value = offset.category;
            document.getElementById('patchName').value = offset.description;
            
            switchTab('patcher');
            document.querySelector('[onclick="switchTab(\'patcher\')"]').click();
            
            showAlert('success', `‚úÖ Loaded offset ${offset.offset} into patch creator`);
        }

        // Hex viewer
        function displayHexView(data, startOffset = 0, rows = 256) {
            const viewer = document.getElementById('hexViewer');
            let html = '';
            
            const endOffset = Math.min(startOffset + (rows * 16), data.length);
            
            for (let i = startOffset; i < endOffset; i += 16) {
                const address = '0x' + i.toString(16).toUpperCase().padStart(8, '0');
                let hexBytes = '';
                let ascii = '';
                
                for (let j = 0; j < 16; j++) {
                    if (i + j < data.length) {
                        const byte = data[i + j];
                        hexBytes += byte.toString(16).toUpperCase().padStart(2, '0') + ' ';
                        ascii += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    } else {
                        hexBytes += '   ';
                        ascii += ' ';
                    }
                }
                
                html += `<div class="hex-row">
                    <div class="hex-address">${address}</div>
                    <div class="hex-bytes">${hexBytes}</div>
                    <div class="hex-ascii">${ascii}</div>
                </div>`;
            }
            
            viewer.innerHTML = html;
        }

        function jumpToOffset() {
            const input = document.getElementById('hexJump').value.trim();
            const offset = parseInt(input.replace('0x', ''), 16);
            
            if (isNaN(offset)) {
                showAlert('error', '‚ùå Invalid offset address');
                return;
            }
            
            if (offset >= romData.length) {
                showAlert('error', '‚ùå Offset exceeds ROM size');
                return;
            }
            
            displayHexView(romData, Math.floor(offset / 16) * 16, 256);
            showAlert('success', `‚úÖ Jumped to offset 0x${offset.toString(16).toUpperCase()}`);
        }

        // Value conversion display
        function updateValueConversion() {
            const input = document.getElementById('patchValue').value.trim();
            const conversionDiv = document.getElementById('valueConversion');
            
            if (!input) {
                conversionDiv.innerHTML = '';
                return;
            }
            
            let value;
            let isHex = input.startsWith('0x') || input.startsWith('0X');
            
            if (isHex) {
                value = parseInt(input.replace(/0x/i, ''), 16);
                if (!isNaN(value) && value <= 0xFF) {
                    conversionDiv.innerHTML = `üí° Decimal: ${value} | Binary: ${value.toString(2).padStart(8, '0')}`;
                } else {
                    conversionDiv.innerHTML = '<span style="color: var(--error);">‚ö†Ô∏è Invalid hex value (max: 0xFF)</span>';
                }
            } else {
                value = parseInt(input, 10);
                if (!isNaN(value) && value <= 255) {
                    conversionDiv.innerHTML = `üí° Hex: 0x${value.toString(16).toUpperCase().padStart(2, '0')} | Binary: ${value.toString(2).padStart(8, '0')}`;
                } else {
                    conversionDiv.innerHTML = '<span style="color: var(--error);">‚ö†Ô∏è Invalid decimal value (max: 255)</span>';
                }
            }
        }

        // Patch creator
        function addPatchToQueue() {
            const name = document.getElementById('patchName').value.trim();
            const desc = document.getElementById('patchDesc').value.trim();
            const offsetInput = document.getElementById('patchOffset').value.trim();
            const valueInput = document.getElementById('patchValue').value.trim();
            const category = document.getElementById('patchCategory').value;

            if (!name || !offsetInput || !valueInput) {
                showAlert('error', '‚ùå Please fill in patch name, offset, and value');
                return;
            }

            // Parse offset (supports both hex and decimal)
            let offsetNum;
            if (offsetInput.startsWith('0x') || offsetInput.startsWith('0X')) {
                offsetNum = parseInt(offsetInput.replace(/0x/i, ''), 16);
            } else {
                offsetNum = parseInt(offsetInput, 10);
            }
            
            if (isNaN(offsetNum)) {
                showAlert('error', '‚ùå Invalid offset format');
                return;
            }

            // Parse value (supports both hex and decimal)
            let valueNum;
            if (valueInput.startsWith('0x') || valueInput.startsWith('0X')) {
                valueNum = parseInt(valueInput.replace(/0x/i, ''), 16);
            } else {
                valueNum = parseInt(valueInput, 10);
            }
            
            if (isNaN(valueNum) || valueNum > 0xFF || valueNum < 0) {
                showAlert('error', '‚ùå Invalid value (must be 0-255 or 0x00-0xFF)');
                return;
            }

            patchQueue.push({
                name,
                desc,
                offset: offsetNum,
                value: valueNum,
                category
            });

            updatePatchQueue();
            
            // Clear inputs
            document.getElementById('patchName').value = '';
            document.getElementById('patchDesc').value = '';
            document.getElementById('patchOffset').value = '';
            document.getElementById('patchValue').value = '';
            document.getElementById('valueConversion').innerHTML = '';
            
            showAlert('success', `‚úÖ Added "${name}" to patch queue`);
        }

        function updatePatchQueue() {
            document.getElementById('patchCount').textContent = patchQueue.length;
            document.getElementById('generateBtn').disabled = patchQueue.length === 0;
            
            const container = document.getElementById('patchItems');
            container.innerHTML = '';
            
            patchQueue.forEach((patch, index) => {
                const item = document.createElement('div');
                item.style.cssText = 'background: var(--bg-dark); padding: 15px; border-radius: 6px; border: 1px solid var(--border);';
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="color: var(--primary); font-weight: 700; margin-bottom: 5px;">
                                ${patch.name}
                                <span class="offset-category cat-${patch.category}" style="margin-left: 10px; font-size: 0.8em;">
                                    ${patch.category.toUpperCase()}
                                </span>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.85em; margin-bottom: 8px;">
                                ${patch.desc || 'No description'}
                            </div>
                            <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.9em;">
                                <span style="color: var(--accent);">Offset:</span> 
                                <code style="color: var(--primary);">0x${patch.offset.toString(16).toUpperCase()}</code>
                                <code style="color: var(--text-secondary); font-size: 0.85em; margin-left: 5px;">(${patch.offset})</code>
                                <br>
                                <span style="color: var(--accent);">Value:</span> 
                                <code style="color: var(--primary);">0x${patch.value.toString(16).toUpperCase()}</code>
                                <code style="color: var(--text-secondary); font-size: 0.85em; margin-left: 5px;">(${patch.value} decimal)</code>
                            </div>
                        </div>
                        <button class="btn btn-danger" style="padding: 6px 12px; font-size: 0.85em;" onclick="removePatchFromQueue(${index})">
                            üóëÔ∏è
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function removePatchFromQueue(index) {
            patchQueue.splice(index, 1);
            updatePatchQueue();
            showAlert('success', '‚úÖ Removed patch from queue');
        }

        function clearPatchQueue() {
            if (patchQueue.length === 0) return;
            if (confirm('Clear all patches from queue?')) {
                patchQueue = [];
                updatePatchQueue();
                showAlert('success', '‚úÖ Patch queue cleared');
            }
        }

        function generateIPSPatch() {
            if (!romData || patchQueue.length === 0) return;

            // Sort patches by offset
            patchQueue.sort((a, b) => a.offset - b.offset);

            // Create IPS patch
            const patches = [];
            
            // IPS header: "PATCH"
            patches.push(0x50, 0x41, 0x54, 0x43, 0x48);

            // Add each patch
            patchQueue.forEach(patch => {
                // Offset (3 bytes, big-endian)
                patches.push((patch.offset >> 16) & 0xFF);
                patches.push((patch.offset >> 8) & 0xFF);
                patches.push(patch.offset & 0xFF);
                
                // Size (2 bytes, big-endian) - always 1 for single byte
                patches.push(0x00);
                patches.push(0x01);
                
                // Data
                patches.push(patch.value);
            });

            // EOF marker
            patches.push(0x45, 0x4F, 0x46);

            // Create blob and download
            const blob = new Blob([new Uint8Array(patches)], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = romFileName.replace(/\.[^.]+$/, '') + '_custom.ips';
            a.click();
            URL.revokeObjectURL(url);

            showAlert('success', `‚úÖ IPS patch generated with ${patchQueue.length} modifications!`);
        }

        function exportOffsets() {
            if (detectedOffsets.length === 0) {
                showAlert('error', '‚ùå No offsets to export. Run AI scan first.');
                return;
            }

            const data = {
                rom: romFileName,
                scanDate: new Date().toISOString(),
                totalOffsets: detectedOffsets.length,
                offsets: detectedOffsets
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = romFileName.replace(/\.[^.]+$/, '') + '_offsets.json';
            a.click();
            URL.revokeObjectURL(url);

            showAlert('success', '‚úÖ Offset map exported successfully!');
        }

        function showAlert(type, message) {
            const alertDiv = document.getElementById('patchAlert');
            alertDiv.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            setTimeout(() => alertDiv.innerHTML = '', 5000);
        }
    </script>
</body>

</html>
